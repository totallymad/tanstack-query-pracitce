import LoadingIndicator from "../UI/LoadingIndicator.jsx"; // Компонент для отображения индикатора загрузки.
import ErrorBlock from "../UI/ErrorBlock.jsx"; // Компонент для отображения ошибок.
import EventItem from "./EventItem.jsx"; // Компонент для отображения отдельного события.
import { fetchEvents } from "../../util/http.js"; // Функция для получения списка событий с сервера.

import { useQuery } from "@tanstack/react-query"; // Хук из TanStack Query для управления запросами данных.

export default function NewEventsSection() {
  // Используем хук useQuery для выполнения асинхронного запроса и управления состоянием данных.
  const { data, isPending, isError, error } = useQuery({
    // Уникальный ключ запроса. Используется для идентификации данных в кэше.
    // Первый элемент массива — это идентификатор ("events"),
    // Второй элемент — объект с параметрами запроса (в данном случае { max: 3 }).
    queryKey: ["events", { max: 3 }],

    // Функция для выполнения запроса. Эта функция должна вернуть данные, которые нужны вашему компоненту.
    // Она принимает объект, содержащий параметры:
    // - signal: используется для отмены запроса, если он ещё не завершён, но больше не нужен.
    // - queryKey: содержит ключ текущего запроса, в данном случае ["events", { max: 3 }].
    queryFn: ({ signal, queryKey }) => fetchEvents({ signal, ...queryKey[1] }),

    // Время, в течение которого данные считаются "свежими" (актуальными), измеряется в миллисекундах.
    // В данном случае это 5000 мс (5 секунд). Если запрос повторится в течение этого времени,
    // данные будут взяты из кэша, а не запрошены заново.
    staleTime: 5000,

    // Время (в миллисекундах), через которое данные, неиспользуемые в приложении, будут удалены из кэша.
    // Закомментировано в данном примере. Можно включить и установить, например, 30000 (30 секунд).
    // gcTime: 30000,
  });

  let content; // Переменная для динамического контента.

  // Если данные еще загружаются, отображаем индикатор загрузки.
  if (isPending) {
    content = <LoadingIndicator />;
  }

  // Если произошла ошибка, отображаем блок с сообщением об ошибке.
  if (isError) {
    content = (
      <ErrorBlock
        title="An error occurred" // Заголовок сообщения об ошибке.
        message={error.info?.message || "Failed to fetch events"} // Сообщение об ошибке.
      />
    );
  }

  // Если данные успешно загружены, отображаем список событий.
  if (data) {
    content = (
      <ul className="events-list">
        {data.map((event) => (
          <li key={event.id}>
            <EventItem event={event} />{" "}
            {/* Компонент для отображения отдельного события. */}
          </li>
        ))}
      </ul>
    );
  }

  // Возвращаем секцию с динамическим содержимым.
  return (
    <section className="content-section" id="new-events-section">
      <header>
        <h2>Recently added events</h2> {/* Заголовок секции. */}
      </header>
      {content}{" "}
      {/* Динамический контент: загрузка, ошибка или список событий. */}
    </section>
  );
}
